@using MemoryMatrix.Models;
@{
    ViewBag.Title = "Memory Matrix";
    Layout = "~/Views/Shared/_Layout.cshtml";
    GameSession gameSession = ViewBag.gameSession;
    Matrix matrix = ViewBag.matrix;
}
@section Head{
    
}

<!-- Bootstrap modal -->
<div id="message-modal" class="modal fade" tabindex="-1" role="dialog">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
                <h4 class="modal-title"><span id="modal-title"></span></h4>
            </div>
            <div class="modal-body">
                <p id="modal-message"></p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
            </div>
        </div><!-- /.modal-content -->
    </div><!-- /.modal-dialog -->
</div><!-- /.modal -->
<!-- End Bootstrap modal -->

<div class="row">
    <div class="col-md-3">
        <table class="table">
            <tbody>
                <tr>
                    <td><h2>Memory Matrix</h2></td>
                </tr>
                <tr>
                    <td><a class="btn btn-default btn-lg btn-block" href="@Url.Action("Index", "Home")" role="button">Main Menu</a></td>
                    
                </tr>
            </tbody>
        </table>
    </div>
    <div class="col-md-6">
        <div style="margin-top:39px;">
            <h4>Level : @gameSession.Level</h4>
        </div>
        <div id="matrix-div" class="matrix" style="width:@(matrix.Width)px;height:@(matrix.Height)px">
            @for (int i = 0; i < matrix.NoOfTiles; i++)
            {
                <div class="tile-container clickable" id="container-@(i+1)" data-tilenumber="@i" style="width:@(matrix.CellWidth)px;height:@(matrix.CellHeight)px">
                    <div class="front white-tile">
                        <!-- front content -->
                    </div>
                    <div class="back red-tile">
                        <!-- back content -->
                    </div>
                </div>
            }
        </div>
        <div class="message-container">
            <span id="message" style="display:none"></span>
        </div>
    </div>
</div>
@section scripts{
    <script src="~/Scripts/bootstrap.min.js"></script>
    <script src="~/Scripts/jquery.flip.min.js"></script>
    <script>
        // Global variables
        var currentLevel = @gameSession.Level;
        var noOfTiles = @matrix.NoOfTiles;

        $(function () {
            // Initialize flip function
            $(".tile-container").flip({
                axis: "y", // y or x
                trigger: "manual", // click or hover
                speed: 400
            });

            // Initialize Modal
            $('#message-modal').modal({
                show: false,
                keyboard: true
            });

            $('#matrix-div').on('click', '.clickable', function () {
                if (MemoryMatrix.Store.getIsClickEnabled()) {
                    var self = $(this);
                    self.flip(true);
                    self.removeClass('clickable');
                    var id = self.attr('id');
                    setTimeout(function() { MemoryMatrix.Game.CheckCorrectPattern(id); }, 400);
                }
            });

            MemoryMatrix.Init.arrangeTiles();
            MemoryMatrix.Init.showTiles();
        });

        var MemoryMatrix = MemoryMatrix || {};

        MemoryMatrix.Store = function () {
            // Private
            var greenTileArray;
            var selectionArray = [];

            var showTileInitialDelay = 1;
            var showTileDuration = 2 + Math.floor(currentLevel / 2);
            var isClickEnabled = false;
            var showMessageDuration = 3000;

            var gameOverMessages = [
                {
                    level : 2,
                    messages : [
                        'Seriously? This is the easiest level and you failed in that?',
                        'You have failed at level ##LEVEL##, Go home, you are drunk...'
                    ]
                },
                {
                    level : 10,
                    messages : [
                        'You are good, this level requires some good memory, way to go!!!',
                        'You have made it till level ##LEVEL##, well played'
                    ]
                }
            ]

            // Public
            return {

                getGreenTileArray: function () {
                    return greenTileArray;
                },
                setGreenTileArray: function (array) {
                    greenTileArray = array;
                },

                getSelectionArray: function () {
                    return selectionArray;
                },
                setSelectionArray: function (array) {
                    selectionArray = array;
                },

                getShowTileInitialDelay: function () {
                    return showTileInitialDelay * 1000;
                },
                getShowTileDuration: function () {
                    return (showTileInitialDelay + showTileDuration) * 1000;
                },

                getIsClickEnabled: function () {
                    return isClickEnabled;
                },
                setIsClickEnabled: function (value) {
                    isClickEnabled = value;
                },

                getShowMessageDuration: function () {
                    return showMessageDuration;
                },
                setShowMessageDuration: function (value) {
                    showMessageDuration = value;
                },

                getGameOverMessage: function(level) {
                    debugger;
                    for(var i = 0; i < gameOverMessages.length; i++) {
                        if(level < gameOverMessages[i].level) {
                            var messageArray = gameOverMessages[i].messages;
                            var min = 0;
                            var max = messageArray.length;
                            var random = Math.floor(Math.random() * (max - min)) + min;
                            var message = messageArray[random];
                            message = message.replace('##LEVEL##', level);
                            return message;
                        }
                    }
                }
            };
        }();

        MemoryMatrix.Init = function () {
            // Private
            var totalGreenTile = Math.sqrt(noOfTiles) * 2 - 1;

            // Calculates the positions of adjacent tiles around the tile of a given position.
            var getAdjacentTiles = function(totalTiles, pos) {
                var adjacentTile = {
                    topLeft : null,
                    top : null,
                    topRight : null,
                    left : null,
                    right : null,
                    bottomLeft : null,
                    bottom : null,
                    bottomRight : null
                };

                var sideLen = Math.sqrt(totalTiles);
                var isOnTop, isFarLeft, isFarRight, isOnBottom;
                isOnTop = isFarLeft = isFarRight = isOnBottom = false;
                
                // Check Top Line
                if (pos < sideLen)
                {
                    // Cell is on top line, there will be no top adjacent cells.
                    isOnTop = true;
                }
                    // Check Bottom Line
                else if (pos >= (totalTiles - sideLen))
                {
                    // Cell is on bottom line, there will be no bottom adjacent cells.
                    isOnBottom = true;
                }

                // Check far left
                if ((sideLen + pos) % sideLen == 0)
                {
                    // Cell is on far left, there will be no left adjacent cells.
                    isFarLeft = true;
                }
                    // Check far right
                else if ((sideLen + pos) % sideLen == (sideLen - 1))
                {
                    // Cell is on far right, there will be no right adjacent cells.
                    isFarRight = true;
                }

                // Calculate coordinates
                // Top Layer
                if (!isOnTop && !isFarLeft)
                    adjacentTile.topLeft = pos - sideLen - 1;

                if (!isOnTop)
                    adjacentTile.top = pos - sideLen;

                if (!isOnTop && !isFarRight)
                    adjacentTile.topRight = pos - sideLen + 1;

                // Middle Layer
                if (!isFarLeft)
                    adjacentTile.left = pos - 1;

                if (!isFarRight)
                    adjacentTile.right = pos + 1;

                // Bottom Layer
                if (!isOnBottom && !isFarLeft)
                    adjacentTile.bottomLeft = pos + sideLen - 1;

                if (!isOnBottom)
                    adjacentTile.bottom = pos + sideLen;

                if (!isOnBottom && !isFarRight)
                    adjacentTile.bottomRight = pos + sideLen + 1;

                return adjacentTile;
            }

            // Searches the green tiles array and returns if the given tile position is adjacent to any of the green tiles in array.
            var isAdjacentToGreenTiles = function(greenTiles,totalTiles, pos) {
                var adjacentTile = getAdjacentTiles(totalTiles, pos);
                if (greenTiles.indexOf(adjacentTile.topLeft) != -1) {
                    return true;
                }
                if (greenTiles.indexOf(adjacentTile.top) != -1) {
                    return true;
                }
                if (greenTiles.indexOf(adjacentTile.topRight) != -1) {
                    return true;
                }
                if (greenTiles.indexOf(adjacentTile.left) != -1) {
                    return true;
                }
                if (greenTiles.indexOf(adjacentTile.right) != -1) {
                    return true;
                }
                if (greenTiles.indexOf(adjacentTile.bottomLeft) != -1) {
                    return true;
                }
                if (greenTiles.indexOf(adjacentTile.bottom) != -1) {
                    return true;
                }
                if (greenTiles.indexOf(adjacentTile.bottomRight) != -1) {
                    return true;
                }
                return false;
            }

            var getRandomInt = function (min, max) {
                return Math.floor(Math.random() * (max - min)) + min;
            }

            // Algorithm for arranging tiles inside the matrix.
            var calculateGreenTiles = function () {
                var greenTileArray = [];
                while (greenTileArray.length != totalGreenTile) {
                    // Calculates Random tile position.
                    var randomInt = getRandomInt(0, noOfTiles);
                    if (greenTileArray.indexOf(randomInt) == -1) {
                        
                        // If there is not tile inside greenTileArray, push the random tile
                        if(greenTileArray.length == 0)
                            greenTileArray.push(randomInt);
                        // Else check if the position is adjacent to any other green tile, if yes; push it inside array.
                        else if(isAdjacentToGreenTiles(greenTileArray, noOfTiles,randomInt))
                            greenTileArray.push(randomInt);
                    }
                }
                MemoryMatrix.Store.setGreenTileArray(greenTileArray);
            };

            var addGreenTiles = function () {
                $('.tile-container').each(function (index, val) {
                    var self = $(this);
                    var tileNumber = parseInt(self.attr('data-tilenumber'));
                    var greenTileArray = MemoryMatrix.Store.getGreenTileArray();
                    if (greenTileArray.indexOf(tileNumber) != -1) {
                        self.addClass('hasRt');
                        self.find('.back').removeClass('red-tile').addClass('green-tile');
                    }
                });
            };

            // Public
            return {
                arrangeTiles: function () {
                    calculateGreenTiles();
                    addGreenTiles();
                },

                showTiles: function () {
                    // Initial delay before showing tiles.
                    setTimeout(function () {
                        $('.hasRt').flip(true);
                    }, MemoryMatrix.Store.getShowTileInitialDelay());

                    // Hide tiles again.
                    setTimeout(function () {
                        $('.hasRt').flip(false);
                        // Enable clicking on matrix.
                        MemoryMatrix.Store.setIsClickEnabled(true);
                    }, MemoryMatrix.Store.getShowTileDuration());
                }
            };
        }();

        MemoryMatrix.Game = function () {
            // Private
            var changeLevel = function (level) {
                $.ajax({
                    type: 'POST',
                    data: { 'level': level },
                    url: '@Url.Action("ChangeLevel","Home")',
                    success: function () {
                        location.reload();
                    }
                });
            };

            var clearSession = function() {
                $.ajax({
                    type: 'POST',
                    url: '@Url.Action("ClearSession","Home")',
                    success: function () { }
                });
            }

            // Public
            return {
                CheckCorrectPattern: function (selectedTileId) {
                    var selectedTile = $('#' + selectedTileId);
                    // Wrong answer
                    if (selectedTile.find('.green-tile').length == 0) {
                        MemoryMatrix.Store.setIsClickEnabled(false);
                        // Clear session to reset the level
                        clearSession();

                        MemoryMatrix.Game.ShowMessage('Wrong selection!!!', true, function() {
                            MemoryMatrix.Game.HideMessage();
                            var message = MemoryMatrix.Store.getGameOverMessage(currentLevel);
                            MemoryMatrix.Game.ShowModal('Game Over', message);
                        });

                        $('.tile-container').flip(true);
                    }
                    else {
                        var selectionArray = MemoryMatrix.Store.getSelectionArray();
                        var totalGreenTiles = MemoryMatrix.Store.getGreenTileArray().length;
                        var tileNumber = parseInt(selectedTile.attr('data-tilenumber'));
                        selectionArray.push(tileNumber);

                        if (selectionArray.length >= totalGreenTiles) {
                            var msg = 'Level ' + currentLevel + ' completed';
                            MemoryMatrix.Game.ShowMessage(msg, false, function() {
                                MemoryMatrix.Game.HideMessage();
                            });
                            MemoryMatrix.Store.setIsClickEnabled(false);
                            setTimeout(function () { changeLevel(currentLevel + 1); }, MemoryMatrix.Store.getShowMessageDuration());
                        }
                        else {
                            MemoryMatrix.Store.setSelectionArray(selectionArray);
                        }
                    }
                },

                ShowMessage: function (message, isFailure, callback) {
                    var msgSpan = $('#message');
                    msgSpan.text(message);
                    if (isFailure)
                        msgSpan.addClass('failure-message');
                    else
                        msgSpan.addClass('success-message');

                    msgSpan.fadeIn(1000);
                    // Call callback function after message duration ended.
                    setTimeout(callback, MemoryMatrix.Store.getShowMessageDuration());
                },

                HideMessage: function () {
                    var msgSpan = $('#message');
                    msgSpan.fadeOut(1000);
                    //msgSpan.text('');
                    msgSpan.removeClass('failure-message');
                    msgSpan.removeClass('success-message');
                },

                ShowModal: function (title, message) {
                    $('#modal-title').text(title);
                    $('#modal-message').text(message);
                    $('#message-modal').modal('show');
                }
            };
        }();
    </script>
}